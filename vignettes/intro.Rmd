---
title: "Introduction to aquamapsdata"
author: "Markus Skyttner"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to aquamapsdata}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This document describes how to use the `aquamapsdata` R data package to access curated data through a static database assembled from data sourced from http://aquamaps.org

Immediately after installing the package, a run-once action is needed, in order to download and locally create the SQLite database containing all the AquaMaps data.

Approximately 5G disk space is needed locally for the database file. The download is around 1G compressed and therefore a speedy Internet connection is recommended for this initial step.

```{r, eval=FALSE}

# install aquamapsdata from GitHub using devtools

install.packages("devtools") 
library("devtools")
install_gitub("raquamaps/aquamapsdata")

# initial run-once step required to install remote db locally

library(aquamapsdata)
download_db(force = TRUE)

```

Once the database is available locally, it can be queried using a couple of different functions.

# Examples

Here is an example of fuzzy and exact name searches, returning keys with the internal identifiers used in the database. Those keys could be said to represent species lists that can be used to retrieve other information, such as environmental envelopes etc.

```{r, message=FALSE}
library(aquamapsdata)
library(dplyr)

# This uses a minified offline db bundled into the package,
# so vignettes can be built in the cloud without requiring a 
# full install and download of the database (time saver)

# NB: normally download_db() would be used 

default_db("extdata")

# fuzzy search allows full text search operators AND, OR, NOT and +
# see https://www.sqlitetutorial.net/sqlite-full-text-search/
am_search_fuzzy(search_term = "trevally") %>% pull(key)

# exact search without parameters returns all results
nrow(am_search_exact())

# exact search giving NULL params shows examples of existing values
# here we see what combinations are present in the dataset for 
# angling, diving, dangerous, highseas, deepwater organisms
am_search_exact(
  angling = NULL, diving = NULL, dangerous = NULL, 
  deepwater = NULL, highseas = NULL, m_invertebrates = NULL)

# exact search without NULL params, specifying values
hits <- 
  am_search_exact(angling = 1, diving = 1, dangerous = 0)

# display results
display <- 
  hits %>% mutate(binomen = paste(Genus, Species)) %>%
  select(SpeciesID, binomen, SpecCode, FBname)

knitr::kable(display)

```

## Species maps

Here we display a map with likely native habitats for the Bluespotted trevally:

```{r "map", echo=TRUE, fig.width=7, message=FALSE}

library(leaflet)
library(raster)
library(aquamapsdata)

# get the identifier for the species
key <- am_search_fuzzy("bluespotted")$key
ras <- am_raster(key)

# show the native habitat map
am_map_leaflet(ras)
```
We can also display a map for several identifiers, with genus "Clupea" at once:

```{r, echo=TRUE, fig.width=7, message=FALSE, eval=FALSE}

keys <- am_search_exact(Genus = "Clupea")$SpeciesID
ras <- am_raster(keys, fun = "count")
am_map_leaflet(ras, title = "Clupea", cols = c("#FFFFFF", "#000000"))

```


## Data scope and content

The `dplyr` package can be used to query the various tables available in the database.

Here is an example showing what tables and fields are included in the data.

First a query for the total record counts:

```{r, message=FALSE, eval = FALSE}

con <- aquamapsdata:::con_am("sqlite")
aquamapsdata:::db_counts(con)
DBI::dbDisconnect(con)
```

Then a description of tables and fields which are included.

```{r}
knitr::kable(am_meta)
```

## Data management

This section describes how the data was prepared for usage in this R package. It may be of interest maybe not primarily for package users, but for those interested in understanding the data preparation steps involved in preparing the dataset for use in this package.

For data management and preparation, several steps are involved in preparing the dataset used in this package. These steps involve moving the relevant parts of the source data from its primary source into a local SQLite3 database that the package uses.

### Local replication of source database

The source data lives in a MySQL/MariaDB database. If this data is made available in the form of a backup from a raw datadir or, preferably, in the form of a data dump, this can be loaded into a local MariaDB database engine. 

With `docker-compose` this can be done in one step, using the command `docker-compose up -d` and this `docker-compose.yml` file:

```yml
volumes:
  db:

services:

  db:
    image: mariadb:latest
    ports:
      - "3306:3306"
    environment:
      - MYSQL_ROOT_PASSWORD=your_root_db_password
      - MYSQL_DATABASE=aquamapsdb
      - MYSQL_USER=your_db_user
      - MYSQL_PASSWORD=your_db_password
    volumes:
      - db:/var/lib/mysql
      - ./aquamaps.sql:/docker-entrypoint-initdb.d/aquamaps.sql:ro

```

After this step, the data is available to access locally through `aquamapsdata::am_con()`.

The "metadata" for table and field names and their descriptions is provided through `aquamapsdata::am_meta` which is prepared by means of (data-raw/am-meta.R). This metadata is used in package documentation and the `am_search_exact()` function allows for taxonomic searches using some of those fields.

### Syncing into SQLite3

A set of functions then allows for syncing the data into an SQLite3 database with full text search support, which gets indexed. 

Relevant steps are:

- Chunkwise sync using `db_sync()` from source connection to target db.
- Add full text search functionality using `am_create_fts()`
- Add indexes through `am_create_indexes()`

### Exposing the data

The function `am_search_exact` takes a lot of parameters, which can be combined, to query the taxonomy in a single call. 

The `am_search_fuzzy` is quick and allows FTS5 search syntax (search terms which can be quoted and also combined with AND, OR, NOT).

These functions returns search results containing keys or identifiers that can be used to retrieve map data in raster format through `am_raster()`. With such a raster a leaflet map can be created with `am_map_leaflet()`.
